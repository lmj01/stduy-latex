\chapter{assembly}
老实说，汇编是没有学到家的，相当于熟悉了一遍它的常用语法，没有实战经验，最主要的是想
学的底层技术,并没有融会贯通于硬件层.
\newline
多年后（2019.6）才理解，微处理器是管理计算机的算术、逻辑、控制等，都有一套专门的指令码，在汇编中称为
opcode，操作码，操作码是二进制形式的，如00000011是加法指令，对应着的文本形式就是ADD，即\textbf{汇编语言是
二进制指令的文本形式，与指令存在一一对应的关系，把汇编的文本转换为二进制后就是CPU的指令码}。

\section{Conception}

\paragraph{Primitive \& Compound}

当年学汇编时，没有学到位，且汇编中的混淆不清的概念影响到后来的学习语言。

任何一门语言都有Primitive Value元值和Compound Values组合值。 这两个概念不能牢记，对于内存块的布局就
不能谈理解到位，每种不同的语言处理这两种的区别都是非常大的，很大例子都是元值，而我的思维很容易就只记住了
这种范式，就没有考虑组合值的处理逻辑。

引入value assigned by value-copy or by value-reference两种概念，什么时候需要copy，什么时候引用，在任何
语言中都会有不同的形式，而在汇编语言中都不关心，都是一个地址而已，这也是这些年来学习其他语言时受到的问题，在
学C时这些就没有吃透，加上汇编在C之后，很多概念就慢慢地沉积下来了。

shallow vs deep copies。上面提到了copy，一个primitive是很容易copy的，但是一个compound就很难处理了，它可能递归
处理很多数据，而且这些数据可能还与某些state状态有关，如共享，竞争等情况下问题就又变复杂了。

上面又会引入一个mutable和immutable， 那些是可以在源地址上进行assigned或modified。特别是高级语言中Object的
含义又是一个很广泛的词，在不同的上下文与语境中理解是存在差异的，混用几种编程语言后就会感觉到很难弄明白，特别是
不了解底层知识，概念的原理，实现上的细节，对此可以说完全是糊糊涂涂地在依葫芦画瓢版用编程语言。

